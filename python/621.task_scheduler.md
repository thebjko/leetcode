# [621. Task Scheduler](https://leetcode.com/problems/task-scheduler/description/?envType=daily-question&envId=2024-03-19)

You are given an array of CPU tasks, each represented by letters A to Z, and a cooling time, `n`. Each cycle or interval allows the completion of one task. Tasks can be completed in any order, but there's a constraint: **identical** tasks must be separated by at least `n` intervals due to cooling time.

â€‹Return the *minimum number* of intervals required to complete all tasks.

## Solutions from Editorial

### Approach 1: Using Priority Queue / Max Heap

```python
class Solution:
    def leastInterval(self, tasks: List[str], n: int) -> int:
        counter = Counter(tasks)

        pq = [-f for f in counter.values()]
        heapify(pq)

        time = 0
        while pq:
            cycle = n + 1
            store = []
            task_count = 0
            while cycle > 0 and pq:
                current_freq = -heappop(pq)
                if current_freq > 1:
                    store.append(-(current_freq - 1))
                task_count += 1
                cycle -= 1

            for x in store:
                heappush(pq, x)
            
            time += task_count if not pq else n + 1
        return time
```

1. We DO NOT need to get an order. Just how long it takes is required.
2. Minimum frequency is first to be taken into consideration. While `cycle` is left, those considered are appended to store decremented by one.
3. `task_count` is kept recorded for `time` in case that task does not endure for full cycle `n + 1`. Otherwise, full cycle `n + 1` is added to `time`.

Since priority queue operation have a time complexity of `O(log k)`, `k` being the number of alphabets - 26, the overall time complexity is `O(N * log k) == O(N)`.

---

There are other approaches and a lot more to learn, but for the time being, I have to leave it as it is, and come back later if there be a chance.
