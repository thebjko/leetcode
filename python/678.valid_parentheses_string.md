# [678. Valid Parentheses String](https://leetcode.com/problems/valid-parenthesis-string/?envType=daily-question&envId=2024-04-07)

Given a string `s` containing only three types of characters: '(', ')' and '*', return `true` if `s` is valid.

The following rules define a valid string:

- Any left parenthesis `'('` must have a corresponding right parenthesis `')'`.
- Any right parenthesis `')'` must have a corresponding left parenthesis `'('`.
- Left parenthesis `'('` must go before the corresponding right parenthesis `')'`.
- `'*'` could be treated as a single right parenthesis `')'` or a single left parenthesis `'('` or an empty string `""`.


## My Attempt

```python
class Solution:
    def checkValidString(self, s: str) -> bool:
        return self._helper(s, [], 0)

    def _helper(self, s, stack, idx) -> bool:
        n = len(s)
        while idx < n:
            if s[idx] == '(':
                stack.append('(')
            elif stack and s[idx] == ')':
                stack.pop()
            elif s[idx] == ')':
                return False
            elif s[idx] == '*':
                one = self._helper(s, stack+['('], idx+1)
                two = self._helper(s, stack, idx+1)
                three = self._helper(s, stack[:-1], idx+1) if stack else None
                return one or two or three
            idx += 1
        return True if not stack else False
```

This approach tries to branch out whenever it encounters `'*'`, but fails in the case of `s = "(())(())(((()*()()()))()((()()(*()())))(((*)()"`

```python
class Solution:
    def checkValidString(self, s: str) -> bool:
        return self._helper(s, 0, 0)

    def _helper(self, s, count, idx) -> bool:
        n = len(s)
        while idx < n:
            if s[idx] == '(':
                count += 1
            elif count and s[idx] == ')':
                count -= 1
            elif s[idx] == ')':
                return False
            elif s[idx] == '*':
                one = self._helper(s, count+1, idx+1)
                two = self._helper(s, count, idx+1)
                three = self._helper(s, count-1, idx+1) if count else None
                return one or two or three
            idx += 1
        return False if count else True
```

This solves the previous case. I think the error is from referencing `stack`. However, it is still prone to TLE(3^100 possibilities in the worst case).

## Solutions from Editorial

### Approach 1: Top-Down Dynamic Programming - Memoization

To solve the issue, use DP table.

```python
class Solution:
    def checkValidString(self, s: str) -> bool:
        n = len(s)
        memo = [[-1] * n for _ in range(n)]
        return self.is_valid_string(0, 0, s, memo)

    def is_valid_string(self, index: int, open_count: int, s: str, memo: List[List[int]]) -> bool:
        if index == len(s):
            return open_count == 0
        
        if memo[index][open_count] != -1:
            return memo[index][open_count] == 1
        
        is_valid = False
        if s[index] == '*':
            is_valid |= self.is_valid_string(index+1, open_count+1, s, memo)
            if open_count > 0:
                is_valid |= self.is_valid_string(index+1, open_count-1, s, memo)
            is_valid |= self.is_valid_string(index+1, open_count, s, memo)
        else:
            if s[index] == '(':
                is_valid = self.is_valid_string(index+1, open_count+1, s, memo)
            elif open_count > 0:
                is_valid = self.is_valid_string(index+1, open_count-1, s, memo)
            
        memo[index][open_count] = 1 if is_valid else 0
        return is_valid
```

This approach uses `open_count` as stack: it does not have to keep the character, but only needs its `len`. 

### Approach 2: Bottom-Up Dynamic Programming - Tabulation

```python
class Solution:
    def checkValidString(self, s: str) -> bool:
        n = len(s)
        dp = [[False] * (n+1) for _ in range(n+1)]

        dp[n][0] = True

        for index in range(n-1, -1, -1):
            for open_bracket in range(n):
                is_valid = False
                if s[index] == '*':
                    if open_bracket < n:
                        is_valid |= dp[index+1][open_bracket+1]
                    if open_bracket > 0:
                        is_valid |= dp[index+1][open_bracket-1]
                    is_valid |= dp[index+1][open_bracket]
                else:
                    if s[index] == '(':
                        is_valid |= dp[index+1][open_bracket+1]
                    elif open_bracket > 0:
                        is_valid |= dp[index+1][open_bracket-1]
                dp[index][open_bracket] = is_valid

		return dp[0][0]
```

Above two approaches basically keep track of `index` and the number of open bracket so far at `n` and keep the record on the table. The bottom up approach starts from the end, with the base case `dp[n][0] = True`. This means that string with no bracket is valid. And on, it checks if the string until the current index from the end is valid. It is only valid if the previous part is valid and the part plus the current character is valid, considering all possible cases. For example, let `s` be `"xxxx)"`, `x` being any other possible characters(`"*"` or `"("`). If it were to be `"("`, then it would not be valid because the parenthesis must be closed to be valid. 

The lower index always refers to the higher to consider if the previous part is valid. `open_bracket` goes up and down or stays the same; it takes account of all possible cases of bracket types(`"("`, `")"`, `"*"`).

#more_to_learn 