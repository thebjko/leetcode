# [678. Valid Parentheses String](https://leetcode.com/problems/valid-parenthesis-string/?envType=daily-question&envId=2024-04-07)

Given a string `s` containing only three types of characters: '(', ')' and '*', return `true` if `s` is valid.

The following rules define a valid string:

- Any left parenthesis `'('` must have a corresponding right parenthesis `')'`.
- Any right parenthesis `')'` must have a corresponding left parenthesis `'('`.
- Left parenthesis `'('` must go before the corresponding right parenthesis `')'`.
- `'*'` could be treated as a single right parenthesis `')'` or a single left parenthesis `'('` or an empty string `""`.


## My Attempt

```python
class Solution:
    def checkValidString(self, s: str) -> bool:
        return self._helper(s, [], 0)

    def _helper(self, s, stack, idx) -> bool:
        n = len(s)
        while idx < n:
            if s[idx] == '(':
                stack.append('(')
            elif stack and s[idx] == ')':
                stack.pop()
            elif s[idx] == ')':
                return False
            elif s[idx] == '*':
                one = self._helper(s, stack+['('], idx+1)
                two = self._helper(s, stack, idx+1)
                three = self._helper(s, stack[:-1], idx+1) if stack else None
                return one or two or three
            idx += 1
        return True if not stack else False
```

This approach tries to branch out whenever it encounters `'*'`, but fails in the case of `s = "(())(())(((()*()()()))()((()()(*()())))(((*)()"`

```python
class Solution:
    def checkValidString(self, s: str) -> bool:
        return self._helper(s, 0, 0)

    def _helper(self, s, count, idx) -> bool:
        n = len(s)
        while idx < n:
            if s[idx] == '(':
                count += 1
            elif count and s[idx] == ')':
                count -= 1
            elif s[idx] == ')':
                return False
            elif s[idx] == '*':
                one = self._helper(s, count+1, idx+1)
                two = self._helper(s, count, idx+1)
                three = self._helper(s, count-1, idx+1) if count else None
                return one or two or three
            idx += 1
        return False if count else True
```

This solves the previous case. I think the error is from referencing `stack`. However, it is still prone to TLE(3^100 possibilities in the worst case).

## Solutions from Editorial

### Approach 1: Top-Down Dynamic Programming - Memoization

To solve the issue, use DP table.

```python
class Solution:
    def checkValidString(self, s: str) -> bool:
        n = len(s)
        memo = [[-1] * n for _ in range(n)]
        return self.is_valid_string(0, 0, s, memo)

    def is_valid_string(self, index: int, open_count: int, s: str, memo: List[List[int]]) -> bool:
        if index == len(s):
            return open_count == 0
        
        if memo[index][open_count] != -1:
            return memo[index][open_count] == 1
        
        is_valid = False
        if s[index] == '*':
            is_valid |= self.is_valid_string(index+1, open_count+1, s, memo)
            if open_count > 0:
                is_valid |= self.is_valid_string(index+1, open_count-1, s, memo)
            is_valid |= self.is_valid_string(index+1, open_count, s, memo)
        else:
            if s[index] == '(':
                is_valid = self.is_valid_string(index+1, open_count+1, s, memo)
            elif open_count > 0:
                is_valid = self.is_valid_string(index+1, open_count-1, s, memo)
            
        memo[index][open_count] = 1 if is_valid else 0
        return is_valid
```

This approach uses `open_count` as stack: it does not have to keep the character, but only needs its `len`. 

#more_to_learn 